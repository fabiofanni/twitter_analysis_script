{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#initi block\n",
    "#!/usr/bin/env python\n",
    "# encoding: utf-8\n",
    "\n",
    "\n",
    "\n",
    "import tweepy #https://github.com/tweepy/tweepy\n",
    "import csv\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import json\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from wordcloud import WordCloud, STOPWORDS\n",
    "import matplotlib.pyplot as plt\n",
    "from textblob import TextBlob\n",
    "\n",
    "#Twitter API credentials\n",
    "credentials={}\n",
    "credentials['consumer_key']=''\n",
    "credentials['consumer_secret']= ''\n",
    "credentials['access_token']=''\n",
    "credentials['access_token_secret']= ''\n",
    "\n",
    "# Save the credentials object to file\n",
    "with open(\"twitter_credentials.json\", \"w\") as file:\n",
    "    json.dump(credentials, file)\n",
    "\n",
    "    #Twitter only allows access to a users most recent 3240 tweets with this method\n",
    "\n",
    "    #authorize twitter, initialize tweepy\n",
    "auth = tweepy.OAuthHandler(credentials['consumer_key'], credentials['consumer_secret'])\n",
    "auth.set_access_token(credentials['access_token'], credentials['access_token_secret'])\n",
    "api = tweepy.API(auth, wait_on_rate_limit=True)\n",
    "\n",
    "print(\"Enter the twitter username:\")\n",
    "username = input()\n",
    "\n",
    "#initialize a list to hold all the tweepy Tweets\n",
    "alltweets = []\n",
    "\n",
    "new_tweets = api.user_timeline(username,count=200)\n",
    "\n",
    "alltweets.extend(new_tweets)\n",
    "\n",
    "oldest = alltweets[-1].id - 1\n",
    "\n",
    "    #keep grabbing tweets until there are no tweets left to grab\n",
    "while len(new_tweets) > 0:\n",
    "    new_tweets = api.user_timeline(username,count=200,max_id=oldest)\n",
    "\n",
    "        #save most recent tweets\n",
    "    alltweets.extend(new_tweets)\n",
    "    oldest = alltweets[-1].id - 1\n",
    "\n",
    "    print(\"%s tweets downloaded\" % (len(alltweets)))\n",
    "\n",
    "outtweets = [[tweet.id_str, tweet.created_at, tweet.text.encode(\"utf-8\")] for tweet in alltweets]\n",
    "\n",
    "    #write the csv\t\n",
    "with open('tweets.csv', 'w') as f:\n",
    "    writer = csv.writer(f)\n",
    "    writer.writerow([\"id\",\"created_at\",\"text\"])\n",
    "    writer.writerows(outtweets)\n",
    "\n",
    "df={}\n",
    "df = pd.read_csv('tweets.csv')\n",
    "\n",
    "\n",
    "df_text = str(df['text'])\n",
    "text.sentiment[0]\n",
    "text = TextBlob(df_text)\n",
    "\n",
    "# Pie chart, where the slices will be ordered and plotted counter-clockwise:\n",
    "labels = 'Subjective', 'Objective'\n",
    "sizes = [text.sentiment[0],(1-(text.sentiment[0]))]\n",
    "explode = (0.1, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n",
    "\n",
    "fig1, ax1 = plt.subplots()\n",
    "ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n",
    "        shadow=True, startangle=90)\n",
    "ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.\n",
    "\n",
    "plt.show()\n",
    "\n",
    "# Pie chart, where the slices will be ordered and plotted counter-clockwise:\n",
    "labels = 'Positive', 'Negative'\n",
    "sizes = [text.sentiment[1],(1-(text.sentiment[1]))]\n",
    "explode = (0.1, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n",
    "\n",
    "fig1, ax1 = plt.subplots()\n",
    "ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n",
    "        shadow=True, startangle=90)\n",
    "ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.\n",
    "\n",
    "plt.show()\n",
    "\n",
    "df['created_at'] = pd.to_datetime(df['created_at'])\n",
    "\n",
    "df.text.values\n",
    "\n",
    "weekly = df.resample('W').count()\n",
    "weekly.plot(style=[':','--', '-'],grid=True,color='#607c8e')\n",
    "plt.title('Tweets Frequency')\n",
    "plt.xlabel('Date')\n",
    "plt.ylabel('Tweets')\n",
    "plt.grid(axis='y', alpha=0.75)\n",
    "\n",
    "\n",
    "text = open(('tweets.csv'), encoding=\"ISO-8859-1\").read()\n",
    "\n",
    "text.encode('ascii', errors='ignore')\n",
    "text = text.replace(\"x80\",\"\")\n",
    "text = text.replace(\"xe2\",\"\")\n",
    "text = text.replace(\"b'\",\"\")\n",
    "text = text.replace(\"https\",\"\")\n",
    "text = text.replace(\"xa6\",\"\")\n",
    "text = text.replace(\"x99\",\"\")\n",
    "text = text.replace(\"co\",\"\")\n",
    "text = text.replace(\"New\",\"\")\n",
    "text = text.replace(\"story\",\"\")\n",
    "text = text.replace(\"via\",\"\")\n",
    "text = text.replace(\"will\",\"\")\n",
    "text = text.replace(\"xf0\",\"\")\n",
    "text = text.replace(\"x9f\",\"\")\n",
    "text = text.replace(\"x87\",\"\")\n",
    "text = text.replace(\"xe3\",\"\")\n",
    "text = text.replace(\"x81\",\"\")\n",
    "text = text.replace(\"RT\",\"\")\n",
    "text = text.replace(\"amp\",\"\")\n",
    "text = text.replace(\"x9d\",\"\")\n",
    "text = text.replace(\"x9f\",\"\")\n",
    "text = text.replace(\"x87\",\"\")\n",
    "text = text.replace(\"xb9\",\"\")\n",
    "text = text.replace(\"xa8\",\"\")\n",
    "text = text.replace(\"x93\",\"\")\n",
    "text = text.replace(\"xa0\",\"\")\n",
    "text = text.replace(\"xb8\",\"\")\n",
    "text = text.replace(\"x8f\",\"\")\n",
    "text = text.replace(\"xa9\",\"\")\n",
    "text = text.replace(\"xc3\",\"\")\n",
    "text = text.replace(\"x98\",\"\")\n",
    "text = text.replace(\"xb4\",\"\")\n",
    "text = text.replace(\"x91\",\"\")\n",
    "text = text.replace(\"x89\",\"\")\n",
    "text = text.replace(\"x98\",\"\")\n",
    "text = text.replace(\"x8a\",\"\")\n",
    "text = text.replace(\"Salvini\",\"\")\n",
    "text = text.replace(username,\"\")\n",
    "\n",
    "stopwords = set(STOPWORDS)\n",
    "\n",
    "#stopwords.update([\"x80\", \"xe2\", \"story\", \"https\", \"xa6\", \"b '%\", \"x99\", \"co\", \"x99s\", \"via\", \"New\", \"RT\", \"WILL\"])\n",
    "\n",
    "# Create and generate a word cloud image:\n",
    "wordcloud = WordCloud(stopwords = stopwords, max_font_size=50, max_words=100, background_color=\"white\").generate(text)\n",
    "\n",
    "# Display the generated image:\n",
    "plt.imshow(wordcloud, interpolation='bilinear')\n",
    "plt.axis(\"off\")\n",
    "plt.show()\n",
    "text = \" \".join(review for review in df.text)\n",
    "print(\"There are {} words in the combination of all review.\".format(len(text)))\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
